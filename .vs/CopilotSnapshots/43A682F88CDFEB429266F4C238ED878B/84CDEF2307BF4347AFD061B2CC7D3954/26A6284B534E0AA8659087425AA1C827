using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;
using System.Collections.Generic;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using System.Threading.Tasks;

public class DragDropController : MonoBehaviour
{
    [Serializable]
    public class Pair
    {
        public string label;                 // e.g., "Tread"
        public string key;                   // e.g., "tread"
        public RectTransform targetRect;     // drop zone on the diagram
        public Vector2 snapOffset;           // small nudge after snap (optional)
    }

    [Header("Config")]
    [SerializeField] private Image diagram;            // optional (for clarity)
    [SerializeField] private RectTransform targetsRoot;
    [SerializeField] private Image targetTemplate;     // disabled template
    [SerializeField] private RectTransform itemsPanel; // where item chips spawn
    [SerializeField] private GameObject winBanner;     // set inactive initially

    [Header("Pairs")]
    [SerializeField] private List<Pair> pairs = new();

    [Header("Item Visuals")]
    [SerializeField] private GameObject itemChipPrefab; // a simple Button + TMP text

    [Header("Events")]
    public UnityEvent OnCompleted; // Hook into your ProgressionController



    private int _lockedCount = 0;
    private readonly Dictionary<string, DropZone> _zonesByKey = new();
    private Canvas _rootCanvas;
    private bool _ended = false;

    // Use string identifiers to match ScoreManager API
    [SerializeField] private string levelId = "Level1";
    [SerializeField] private string miniGameId = "Quiz1";
    [SerializeField] private int pointsPerItem = 10;

    void Awake()
    {
        _rootCanvas = GetComponentInParent<Canvas>();
        if (winBanner != null) winBanner.SetActive(false);

        // Build DropZones from targets list
        foreach (var p in pairs)
        {
            if (p.targetRect == null || string.IsNullOrEmpty(p.key)) continue;

            // Clone a target from template (keeps it all prefab-contained)
            var zoneImg = Instantiate(targetTemplate, targetsRoot);
            zoneImg.gameObject.name = $"Target_{p.key}";
            zoneImg.rectTransform.position = p.targetRect.position;
            zoneImg.rectTransform.sizeDelta = p.targetRect.sizeDelta;
            zoneImg.gameObject.SetActive(true);

            var zone = zoneImg.gameObject.AddComponent<DropZone>();
            zone.Init(p.key, p.snapOffset);

            _zonesByKey[p.key] = zone;
        }

        // Spawn Draggable Items
        foreach (var p in pairs)
        {
            if (string.IsNullOrEmpty(p.label) || string.IsNullOrEmpty(p.key)) continue;

            var go = Instantiate(itemChipPrefab, itemsPanel);
            go.name = $"Item_{p.key}";

            var txt = go.GetComponentInChildren<TMP_Text>();
            if (txt) txt.text = p.label;

            var cg = go.GetComponent<CanvasGroup>();
            if (!cg) cg = go.AddComponent<CanvasGroup>();

            var rt = go.GetComponent<RectTransform>();

            var drag = go.AddComponent<DraggableItem>();
            drag.Init(p.key, this, _rootCanvas, cg, rt);
        }
    }

    // Called by DraggableItem when released
    public void TryPlace(DraggableItem item, PointerEventData eventData)
    {
        // Raycast UI to find a DropZone under pointer
        var results = new List<RaycastResult>();
        EventSystem.current.RaycastAll(eventData, results);

        Debug.Log($"TryPlace: {item.Key} - Found {results.Count} raycast results");

        foreach (var r in results)
        {
            // Check both the object itself and its parents for DropZone
            var zone = r.gameObject.GetComponent<DropZone>();
            if (zone == null)
            {
                zone = r.gameObject.GetComponentInParent<DropZone>();
            }

            if (zone != null)
            {
                Debug.Log($"Found zone: {zone.Key}, Item: {item.Key}, Locked: {zone.IsLocked}, Match: {zone.Key == item.Key}");
                
                if (zone.Key == item.Key && !zone.IsLocked)
                {
                    Debug.Log($"✓ Locking {item.Key} to zone!");
                    // Snap & lock
                    zone.LockToZone(item.RectTransform);
                    _lockedCount++;
                    item.Lock();
                    CheckComplete();
                    return;
                }
            }
        }

        Debug.Log($"✗ No valid zone found for {item.Key} - resetting to start");
        // No valid zone: return to original parent/anchored position
        item.ResetToStart();
    }

    private void CheckComplete()
    {
        if (_ended) return;

        if (_lockedCount >= _zonesByKey.Count && _zonesByKey.Count > 0)
        {
            _ended = true;
            if (winBanner != null) winBanner.SetActive(true);
            OnCompleted?.Invoke();
            EndGame();
        }
    }

    public void EndGame()
    {
        if (!_ended) _ended = true;

        int finalScore = CalculateFinalScore();

        // Report mini-game score if ScoreManager exists
        try
        {
            // reference the type explicitly to avoid name resolution issues
            if (global::ScoreManager.Instance != null)
            {
                global::ScoreManager.Instance.ReportMiniGameScore(levelId, miniGameId, finalScore);
            }
            else
            {
                Debug.LogWarning("ScoreManager.Instance is null. Skipping mini-game score report.");
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Reporting mini-game score failed: {ex.Message}");
        }

        // Fire-and-forget upload of total score
        try
        {
            var uploader = UnityEngine.Object.FindFirstObjectByType<global::TotalScoreUploader>();
            if (uploader != null)
            {
                _ = RunUploadAsync(uploader);
            }
            else
            {
                Debug.LogWarning("TotalScoreUploader not found in scene. Skipping total upload.");
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Total score upload failed: {ex.Message}");
        }
    }

    // Add RunUploadAsync helper
    private async Task RunUploadAsync(global::TotalScoreUploader uploader)
    {
        try
        {
            await uploader.UploadScoreAsync();
            Debug.Log("Total score uploaded successfully.");
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Total score upload failed: {ex.Message}");
        }
    }

    private int CalculateFinalScore()
    {
        // Simple and backward-compatible formula — adjust if you want other rules
        return _lockedCount * Mathf.Max(1, pointsPerItem);
    }
}
